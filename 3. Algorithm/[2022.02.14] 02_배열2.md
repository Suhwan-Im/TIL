# 2022.02.14 (월)

## Array 2 (배열 2)




### 배열: 2차원 배열

- 1차원 리스트를 묶어놓은 리스트 (예: `A = [[1, 2, 3, 4], [5, 6, 7, 8]]`)
- 2차원 이상의 다차원 리스트는 차원에 따라 index를 선언 (예: `A[1][2] = 7`)
- 전치행렬 (transpose)
  - 행과 열을 바꾸는 것 (좌상-우하 대각선을 기준으로 대칭위치끼리 교환)




### 부분집합 생성

- 비트 연산자
  - `&`: 비트 단위로 AND 연산을 한다
  - `|`: 비트 단위로 OR 연산을 한다
  - `<<`: 피연산자의 비트 열을 왼쪽으로 이동시킨다 (시프트 연산)
  - `>>`: 피연산자의 비트 열을 오른쪽으로 이동시킨다 (시프트 연산)

- << 연산자
  - `1 << n` : 2^n. 즉, 원소가 n개일 경우의 모든 부분집합의 수를 의미함
    - 1을 왼쪽으로 n번 시프트 (예: `1 << 2`는 0001 -> 0100  = 2^2 = 4)

- & 연산자
  - `i & (1<<j)` : i의 j번째 비트가 1인지 아닌지를 리턴




### 순차 검색 (Sequential Search)

- 일렬로 되어 있는 자료를 순서대로 검색하는 방법
  - 가장 간단하고 직관적인 검색 방법
  - 알고리즘이 단순하여 구현이 쉽지만, 검색 대상의 수가 많은 경우에는 수행시간이 급격히 증가하여 비효율적
- 2가지 경우
  - 정렬되어 있지 않은 경우
    - 첫번째 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교하며 찾기
    - 키 값이 동일한 원소를 찾으면 그 원소의 인덱스를 반환
    - 시간 복잡도: O(n)
  - 정렬되어 있는 경우
    - 자료를 순차적으로 검색하면서 키 값을 비교하고, 원소의 키 값이 검색 대상의 키 값보다 크면 검색을 종료
    - 시간 복잡도: O(n)



### 이진 검색 (Binary Search)

- 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법
- 이진 검색을 하기 위해서는 자료가 정렬된 상태여야 함
- 검색 과정
  - 자료의 중앙에 있는 원소를 고른다
  - 중앙 원소의 값과 찾고자 하는 목표 값을 비교한다
  - 목표 값이 더 작으면 왼쪽의 반에 대해서 새로 검색을, 더 크면 오른쪽의 반에 대해서 새로 검색을 수행
  - 찾고자 하는 값을 찾을때까지 위의 과정을 반복 




### 선택 정렬 (Selection Sort)

- 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식
- 정렬 과정
  - 주어진 리스트 중에서 최소값을 찾는다
  - 그 값을 리스트의 맨 앞에 위치한 값과 교환한다
  - 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다
- 시간 복잡도: O(n2)



### 셀렉션 알고리즘 (Selection Algorithm)

- 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법
  - 최소값, 최대값, 또는 중간값을 찾는 알고리즘을 의미하기도 함
- 선택 과정
  - 정렬 알고리즘을 이용하여 자료를 정렬
  - 원하는 순서에 있는 원소 가져오기
- 시간 복잡도: O(kn)
